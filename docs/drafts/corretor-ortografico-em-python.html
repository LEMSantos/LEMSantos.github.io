<!DOCTYPE html>
<html lang="pt-br">
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SW1LL2DZZ5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-SW1LL2DZZ5');
</script>
        <title>LEMSantos</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta charset="utf-8" />
        <!-- twitter card metadata -->
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="/images/avatar.webp">
<meta name="twitter:site" content="">
<meta name="twitter:title" content="Criando um corretor ortográfico simples utilizando Python">
<meta name="twitter:description" content="Nesse post vamos construir um corretor ortográfico simples utilizando Python, que apresenta uma boa performance. Esse corretor é baseado na versão desenvolvida pelo Peter Norvig.">
        <!-- OG Tags -->
<meta property="og:url" content="/drafts/corretor-ortografico-em-python.html"/>
<meta property="og:title" content="LEMSantos | Criando um corretor ortográfico simples utilizando Python" />
<meta property="og:description" content="Nesse post vamos construir um corretor ortográfico simples utilizando Python, que apresenta uma boa performance. Esse corretor é baseado na versão desenvolvida pelo Peter Norvig." />
        <!-- favicon -->
        <link rel="icon" type="image/png" href="/images/pelly.png">
        <!-- moment.js for date formatting -->
        <script src="/theme/js/moment.js"></script>
        <script src="/theme/js/app.js"></script>
        <script>
            moment.locale('pt-br')
        </script>
        <!-- css -->
        <link rel="stylesheet" type="text/css" href="/theme/css/main.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
		<script>

                /*! grunt-grunticon Stylesheet Loader - v2.1.2 | https://github.com/filamentgroup/grunticon | (c) 2015 Scott Jehl, Filament Group, Inc. | MIT license. */

    (function(e){function t(t,n,r,o){"use strict";function a(){for(var e,n=0;u.length>n;n++)u[n].href&&u[n].href.indexOf(t)>-1&&(e=!0);e?i.media=r||"all":setTimeout(a)}var i=e.document.createElement("link"),l=n||e.document.getElementsByTagName("script")[0],u=e.document.styleSheets;return i.rel="stylesheet",i.href=t,i.media="only x",i.onload=o||null,l.parentNode.insertBefore(i,l),a(),i}var n=function(r,o){"use strict";if(r&&3===r.length){var a=e.navigator,i=e.Image,l=!(!document.createElementNS||!document.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect||!document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image","1.1")||e.opera&&-1===a.userAgent.indexOf("Chrome")||-1!==a.userAgent.indexOf("Series40")),u=new i;u.onerror=function(){n.method="png",n.href=r[2],t(r[2])},u.onload=function(){var e=1===u.width&&1===u.height,a=r[e&&l?0:e?1:2];n.method=e&&l?"svg":e?"datapng":"png",n.href=a,t(a,null,null,o)},u.src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==",document.documentElement.className+=" grunticon"}};n.loadCSS=t,e.grunticon=n})(this);(function(e,t){"use strict";var n=t.document,r="grunticon:",o=function(e){if(n.attachEvent?"complete"===n.readyState:"loading"!==n.readyState)e();else{var t=!1;n.addEventListener("readystatechange",function(){t||(t=!0,e())},!1)}},a=function(e){return t.document.querySelector('link[href$="'+e+'"]')},c=function(e){var t,n,o,a,c,i,u={};if(t=e.sheet,!t)return u;n=t.cssRules?t.cssRules:t.rules;for(var l=0;n.length>l;l++)o=n[l].cssText,a=r+n[l].selectorText,c=o.split(");")[0].match(/US\-ASCII\,([^"']+)/),c&&c[1]&&(i=decodeURIComponent(c[1]),u[a]=i);return u},i=function(e){var t,o,a;o="data-grunticon-embed";for(var c in e)if(a=c.slice(r.length),t=n.querySelectorAll(a+"["+o+"]"),t.length)for(var i=0;t.length>i;i++)t[i].innerHTML=e[c],t[i].style.backgroundImage="none",t[i].removeAttribute(o);return t},u=function(t){"svg"===e.method&&o(function(){i(c(a(e.href))),"function"==typeof t&&t()})};e.embedIcons=i,e.getCSS=a,e.getIcons=c,e.ready=o,e.svgLoadedCallback=u,e.embedSVG=u})(grunticon,this);

                grunticon(["/theme/css/icons.data.svg.css", "/theme/css/icons.data.png.css", "/theme/css/icons.fallback.css"]);
            </script>
        <noscript><link href="/theme/css/icons.fallback.css" rel="stylesheet"></noscript>
        <!-- menu toggle javascript -->
        <script type="text/javascript">
            document.addEventListener("DOMContentLoaded", initMenu);

            function initMenu(){
                var menu = document.getElementById("menu");
                var menulink = document.getElementById("menu-link");
                menulink.addEventListener("click", function toggleMenu(){
                        window.event.preventDefault();
                        menulink.classList.toggle('active');
                        menu.classList.toggle('active');
                    });
            };
        </script>

    <meta name="description" content="Nesse post vamos construir um corretor ortográfico simples utilizando Python, que apresenta uma boa performance. Esse corretor é baseado na versão desenvolvida pelo Peter Norvig." />

    <meta name="tags" content="Corretor ortográfico" />
    <meta name="tags" content="NLP" />
    <meta name="tags" content="Python" />

</head>
<body>
    <div role="banner" id="masthead">
        <header style="
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 266px;
            overflow-y: auto;
        ">
                <a href="/" style="
                    text-decoration: none;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                ">
                    <img
                        src="/images/avatar.webp"
                        alt="McManus Logo"
                    >

                    <h1 style="
                        margin-top: 1em;
                        font-size: 1.5em;
                        display: inline-block;
                    ">
                        Lucas Eliaquim
                    </h1>
                </a>
            <a href="#menu" id="menu-link">mais coisas</a>
            <nav id="menu" style="
                display: flex;
                flex-direction: column;
                align-items: center;
            ">
                <ul>
                        <li><a href="/pages/resume.html">Currículo</a></li>
                        <li><a href="/pages/portfolio.html">Portfólio</a></li>
                </ul>

                    <div style="
                        text-align: center;
                        margin-top: 3em;
                        font-weight: bold;
                    ">
                        Categorias
                        <hr style="width: 200px">
                    </div>

                    <ul>
                            <li class="active"><a href="/category/nlp.html">NLP</a></li>
                    </ul>
            </nav>
        </header>
    </div>
        <div class="page" role="main">
  <div class="article" role="article">
    <article>
        <footer>
            <a name="top"></a>
            <p>
              <time datetime=" 2022-07-23 08:36:00-03:00">
                <script>document.write(moment('2022-07-23 08:36:00-03:00').format('LL'));</script>
              </time>
            </p>
        </footer>
        <header>
          <h2>
            Criando um corretor ortográfico simples utilizando Python
          </h2>
        </header>
      <div class="content">
         <p><img alt="React: JavaScript library" src="/images/spell-checker-2.jpg"></p>
<p style="text-align: center; margin-top: -27px"><em><a href='https://br.freepik.com/fotos-vetores-gratis/ilustracao'>Ilustração vetor criado por pch.vector - br.freepik.com</a></em></p>

<p>Bom dia, Boa tarde ou Boa noite (dependendo da hora que você está lendo esse artigo), nesse post vamos tentar resolver o problema de criar um corretor ortográfico simples utilizando Python. O conteúdo desse post foi baseado em um atigo criado pelo Peter Norvig em 2007, com o título <strong><a href="https://norvig.com/spell-correct.html" target="_blank">How to Write a Spelling Corrector</a></strong>. Pensei em falar um pouco sobre isso, porque considero esse assunto muito interessante e acredito que existem outras pessoas que, como eu, pensam o mesmo.</p>
<p>O objetivo desse artigo é ajudar as pessoas que não estão tão familiarizadas com a lingua inglesa, ou mesmo não entenderam muito bem o que o Norvig quis dizer. A minha ideia geral é tentar simplificar o máximo possível a parte estatística e matemática, e quem sabe simplificar um pouco do código.</p>
<p>Como eu faço sempre em meus artigos, segue uma lista de requisitos para ajudar você a aproveitar melhor o conteúdo:</p>
<ol>
<li>O primeiro requisito é ter o interpretador de Python instalado;</li>
<li>O segundo é entender o básico da linguagem Python:<ul>
<li>Variáveis e tipos de dados;</li>
<li>Estruturas de condição e repetição;</li>
<li>Funções.</li>
</ul>
</li>
</ol>
<p>Bom, agora que definimos o que precisamos, vamos começar os trabalhos. A primeira coisa que precisamos entender é como esse corretor funciona.</p>
<h2>Vá direto ao assunto...</h2>
<ul>
<li><a href="#como-o-corretor-funciona">Como o corretor funciona</a>;</li>
<li><a href="#a-implementacao">A Implementação</a>;<ul>
<li><a href="#vocabulario">Lendo o vocabulário</a>;</li>
<li><a href="#operacoes-basicas">Operações básicas</a>;</li>
<li><a href="#gerando-candidatos">Gerando candidatos</a>;</li>
<li><a href="#colocando-tudo-junto">Colocando tudo junto</a>.</li>
</ul>
</li>
<li><a href="#executando-testes">Executando testes</a>;</li>
<li><a href="#sugestoes-de-melhoria">Sugestões de melhoria</a>;</li>
<li><a href="#recapitulando">Recapitulando</a>.</li>
</ul>
<p><a id="como-o-corretor-funciona"></a></p>
<h2>Como o corretor funciona</h2>
<p>Um corretor ortográfico é uma pessoa ou programa de computador que faz a verificação de um texto ou uma palavra para achar e corrigir erros tipográficos ocasionais.</p>
<p>Na lingua portuguesa, alguns erros comuns podem acontecer quando estamos digitando. Podemos, por exemplo:</p>
<ul>
<li>Adicionar uma ou mais letras em uma palavra;</li>
<li>"Engolir" letras quando estamos digitando;</li>
<li>Trocar duas ou mais letras de uma palavra;</li>
<li>Colocar letras que não fazem parte da palavra, como por exemplo, confundir <strong>s</strong> e <strong>z</strong>.</li>
</ul>
<p>Existem outros erros que podem acontecer, porém vamos nos forcar apenas nesses quatro.</p>
<p>Sendo uma pessoa esperta, acredito que uma certa pergunta pode ter surgido na sua mente: Como fazemos para corrigir esse tipo de erro?</p>
<p>Uma forma bem intuitiva de pensar seria: Podemos gerar todas as palavras possíveis, inserindo, removendo, trocando ou colocando novas letras, e selecionar a palavra que tem a maior chance de ser a correção da palavra original. Muito bem, é exatamente o que vamos fazer. A nossa linha de pensamento pode ser dividida em quatro operações distintas:</p>
<ul>
<li>Gerar os possíveis candidatos;</li>
<li>Definir quais candidatos podem ser uma correção para a nossa palavra;</li>
<li>Definir a chance de cada candidato;</li>
<li>Escolher o candidato que tem a maior chance de ser a correção.</li>
</ul>
<p><strong>Gerar os possíveis candidatos</strong>: Vamos apenas criar variações da nossa palavra, inserindo, removendo, trocando ou colocando novas letras. Cada variação precisa ser gerada, dado que não sabemos qual é a correta.</p>
<p><strong>Definir os cadidados plausíveis</strong>: Se pensarmos bem, uma palavra de <code>N</code> letras vai ter <code>N</code> remoções, <code>N - 1</code> trocas entre as letras já existentes, <code>26N</code> trocas por novas letras e por fim <code>26(N - 1)</code> inserções, totalizando <code>54N + 25</code> variações (muitas delas podem ser duplicadas). Para uma palavra de 10 letras, ou seja <code>N=10</code>, teríamos 565 variações. Como esse número é grande, talvez uma das formas de reduzir seja eliminando as variações que não fazem parte do nosso vocabulário.</p>
<p><strong>Definir a chance de cada candidato</strong>: Para definir a chance de cada candidato precisamos saber qual a probabilidade de cada palavra aparecer em um texto. Imagino que você já deve ter pensado nisso, mas uma das formas é pegar um texto, ou vários textos e contar quantas vezes cada palavra aparece. Dessa forma, saberemos qual palavra é mais provável de aparecer.</p>
<p><strong>Escolher o candidato</strong>: Se já temos os candidatos e a chance de cada candidato de ser a correção para a palavra, só precisamos selecionar aquele que tem a maior chance.</p>
<p>Essas operações compõem as etapas que o nosso corretor precisa executar sempre que a correção de uma nova palavra for solicitada. Agora que definimos toda a linha de prensamento que precisamos, podemos partir para a implementação.</p>
<p><a id="a-implementacao"></a></p>
<h2>A implementação</h2>
<p>Podemos dividir a nossa implementação em algumas etapas. Essa divisão vai nos ajudar a entender melhor cada parte do nosso corretor. Dentre as fases, temos: a leitura do vocabulário, ou seja, a frenquência das palavras, a criação das operações básicas para gerar os candidatos, gerar de fato os candidatos e por fim, colocar tudo junto para finalizar o corretor.</p>
<p><a id="vocabulario"></a></p>
<h4>Lendo o vocabulário</h4>
<p>O nosso vocabulário vai ser basicamente um arquivo <code>.txt</code> em que vamos colocar cada palavra e sua respectiva frequência. Para ilustrar, esse arquivo vai estar no formato abaixo:</p>
<div class="highlight"><pre><span></span><code>que 15044152
não 12169729
o 12005035
de 10121551
a 8992538
é 8594955
você 7817147
e 7345808
</code></pre></div>

<p>Esse arquivo que vamos utilizar é uma contagem de palavras gerada a partir do <a href="https://www.opensubtitles.org/pt" target="_blank">OpenSubtitles</a>, que é a maior base de dados de legendas em diversas linguas. O arquivo do vocabulário <a href="/docs/vocabulary.txt" target="_blank">pode ser encontrado aqui</a>. Vamos chamá-lo de <strong><code>vocabulary.txt</code></strong>. Você pode conferir também o <a href="https://github.com/hermitdave/FrequencyWords/blob/master/content/2018/pt_br/pt_br_50k.txt">aquivo original</a> está no github.</p>
<p>Como o nosso arquivo vai ter a palavra e a respectiva frequência separadas por um espaço, podemos modelar o nosso código com os seguintes passos:</p>
<ul>
<li>Abrir o arquivo <strong><code>vocabulary.txt</code></strong>;</li>
<li>Ler o texto completo e separar cada uma das linhas;</li>
<li>Para cada linha, separar a palavra da frequência;</li>
<li>Criar um <strong><code>Counter</code></strong> para armazenar essas frequências;</li>
<li>Somar as frequências para saber o total de palavras consideradas. Vamos utilizar isso para calcular a probabilidade de cada palavra;</li>
<li>Retornar tanto a soma, quanto o <strong><code>Counter</code></strong>.</li>
</ul>
<p>O código a seguir ilustra a definição de uma função para realizar essas ações.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>


<span class="k">def</span> <span class="nf">read_vocabulary</span><span class="p">():</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;vocabulary.txt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">vocab_file</span><span class="p">:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">vocab_file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>

    <span class="n">full_vocab</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">]</span>
    <span class="n">words_counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">({</span><span class="n">word</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="k">for</span> <span class="n">word</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">full_vocab</span><span class="p">})</span>

    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">words_counter</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">words_counter</span>
</code></pre></div>

<p>O <strong><code>Counter</code></strong> é apenas uma estrutura nativa do Python para guardar frequências. É uma estrutura semelhante a um dicionário, onde teremos a palavra como chave e a frequência como valor. Algo como:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">({</span><span class="s1">&#39;que&#39;</span><span class="p">:</span> <span class="mi">15044152</span><span class="p">})</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span><span class="p">[</span><span class="s1">&#39;que&#39;</span><span class="p">]</span>
<span class="mi">15044152</span>
</code></pre></div>

<p><a id="operacoes-basicas"></a></p>
<h4>Operações básicas</h4>
<p>Agora que definimos como será a leitura do nosso vocabulário, vamos partir para as operações básicas de inserção, remoção, troca e substituição. Começameros com a função para criar candidatos a partir de inserção.</p>
<div class="highlight"><pre><span></span><code><span class="n">LETTERS</span> <span class="o">=</span> <span class="s1">&#39;abcdefghijklmnopqrstuvwxyzàáâãèéêìíîòóôõùúûç&#39;</span>

<span class="c1"># &lt;FUNÇÕES DEFINIDAS ANTERIORMENTE FICAM AQUI&gt;</span>


<span class="k">def</span> <span class="nf">generate_by_insert</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="n">generated_words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">LETTERS</span><span class="p">:</span>
            <span class="n">generated_words</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">word</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="n">letter</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">pos</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">generated_words</span>
</code></pre></div>

<p>Basicamente a função de gerar candidatos por inserção recebe a palavra como parâmetro e para cada posição inserimos cada uma das letras possíveis. Essa operação divide a palavra em duas partes, lado direito e lado esquerdo. Então ela insere entre as duas partes uma nova letra.</p>
<p>Seguindo, vamos definir a função para gerar candidatos através de remoção.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">generated_by_delete</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="n">generated_words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">generated_words</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">word</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">generated_words</span>
</code></pre></div>

<p>Mesmo esquema da função de inserção, com a diferença de retirar as letras ao invés de inserir. Essa remoção pode ser vista quando descartamos uma das letras da parte direita com o trecho <strong><code>word[pos + 1:]</code></strong>.</p>
<p>A próxima operação é para gerar candidatos através de substituição.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">generate_by_replace</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="n">generated_words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">LETTERS</span><span class="p">:</span>
            <span class="n">generated_words</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">word</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="n">letter</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">generated_words</span>
</code></pre></div>

<p>A ideia dessa operação é muito similar a de remoção, com a diferença que ao invés de descartar uma letra, colocamos outra no lugar.</p>
<p>Por último, mas não menos importante, precisamos definir uma função para gerar candidatos através de troca.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">generate_by_swap</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="n">generated_words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">generated_words</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
            <span class="n">word</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:]</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">generated_words</span>
</code></pre></div>

<p>Essa operação simplesmente troca letras dentro da própria palavra, considerando que podem existir erros de digitação onde invertemos a ordem das letras.</p>
<p>Com as operações básicas definidas, podemos finalmente partir para a geração de candidatos.</p>
<p><a id="gerando-candidatos"></a></p>
<h4>Gerando candidatos</h4>
<p>Para gerar os candidatos que servirão para corrigir a palavra, precisamos pensar que nem sempre erramos apenas uma vez quando estamos digitando uma palavra. Assim, pode ser que seja necessário criar variações onde um ou mais erros possam ser corridos. Primeiramente vamos resolver o problema de gerar os candidatos para apenas um erro, ou falando de outra forma, com distância igual a 1 em relação a palavra original.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">words_generator_1_dist</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="n">inserts</span> <span class="o">=</span> <span class="n">generate_by_insert</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
    <span class="n">deletes</span> <span class="o">=</span> <span class="n">generated_by_delete</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
    <span class="n">replaces</span> <span class="o">=</span> <span class="n">generate_by_replace</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
    <span class="n">swaps</span> <span class="o">=</span> <span class="n">generate_by_swap</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">inserts</span> <span class="o">|</span> <span class="n">deletes</span> <span class="o">|</span> <span class="n">replaces</span> <span class="o">|</span> <span class="n">swaps</span>
</code></pre></div>

<p>Nessa função, simplesmente geramos as variações baseadas em cada uma das operações e depois fazemos a união de todas elas. Assim, teremos um conjunto com todas as palavras com distância igual 1 em relação a palavra passada como parâmetro.</p>
<p>Para resolver o problema da distância igual a 2, ou seja, com a possibilidade de 2 erros sendo cometidos ao mesmo tempo, podemos definir a função como segue:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">words_generator_2_dist</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="n">words_2_dist</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">new_word</span> <span class="ow">in</span> <span class="n">words_generator_1_dist</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
        <span class="n">words_2_dist</span> <span class="o">|=</span> <span class="n">words_generator_1_dist</span><span class="p">(</span><span class="n">new_word</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">words_2_dist</span>
</code></pre></div>

<p>Basicamente estamos considerando que, se para cada palavra com distância igual a 1, gerarmos outra palavra com distância igual a 1, conseguimos gerar palavras com distância total igual a 2 em relação a palavra original.</p>
<p>Podemos continuar gerando palavras com mais distâncias para cobrir a maior quantidade possível de erros, porém para cada nova possibilidade que pensamos, a quantidade de palavras aumenta vertiginosamente. Dessa forma, em algum momento podemos não conseguir mais lidar com a quantidade imensa de palavras e acabar eliminando a eficiência do nosso corretor.</p>
<p>Você vai ver que para a grande maioria dos casos, a distância máxima igual a 2 já é o suficiente.</p>
<p>Bom, agora que definimos funções auxiliares para gerar as variações das palavras, podemos enfim selecionar os candidatos mais adequados.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">candidates</span><span class="p">(</span><span class="n">misspelled_word</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">known_words</span><span class="p">({</span><span class="n">misspelled_word</span><span class="p">})</span> <span class="ow">or</span>
            <span class="n">known_words</span><span class="p">(</span><span class="n">words_generator_1_dist</span><span class="p">(</span><span class="n">misspelled_word</span><span class="p">))</span> <span class="ow">or</span>
            <span class="n">known_words</span><span class="p">(</span><span class="n">words_generator_2_dist</span><span class="p">(</span><span class="n">misspelled_word</span><span class="p">))</span> <span class="ow">or</span>
            <span class="p">{</span><span class="n">misspelled_word</span><span class="p">})</span>
</code></pre></div>

<p>Para definir quem é um candidato adequado, precisamos definir um modelo de seleção. Como não temos nenhum banco de erros ortográficos para analisar, podemos pensar em algumas regrinhas simples.</p>
<ul>
<li>Se a palavra que foi passada para ser corrigida já existe no nosso vocabulário, então provavelmente ela não precisa ser corrigida. Retornamos ela;</li>
<li>Ou se, ao gerar variações considerando a distância igual a 1 encontrarmos palavras existentes no vacabulário, então provavelmente elas são os candidatos corretos;</li>
<li>Ou se, ao gerar variações considerando a distância igual a 2 encontrarmos palavras existentes no vacabulário, então provavelmente elas são os candidatos corretos;</li>
<li>Se não, retornamos a própria palavra que foi passada, dado que não encontramos correção para ela.</li>
</ul>
<p>Nesse caso estamos levando em consideração que errar apenas uma vez é mais provável do que errar duas vezes.</p>
<p>Apenas uma coisa faltou, definir a função <strong><code>known_words</code></strong>, que nos retorna quais palavras de um conjunto estão presentes no nosso vocabulário.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">known_words</span><span class="p">(</span><span class="n">words_set</span><span class="p">):</span>
    <span class="n">vocabulary_words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">VOCABULARY</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">words_set</span> <span class="o">&amp;</span> <span class="n">vocabulary_words</span>
</code></pre></div>

<p>A variável <strong><code>VOCABULARY</code></strong> será definida posteriormente.</p>
<p><a id="colocando-tudo-junto"></a></p>
<h4>Colocando tudo junto</h4>
<p>Agora que temos todas as funções necessárias para gerar os candidatos para a efetuar a correção, podemos enfim definir a função que de fato faz a correção.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">correct</span><span class="p">(</span><span class="n">misspelled_word</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">candidates</span><span class="p">(</span><span class="n">misspelled_word</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">probability_of_word</span><span class="p">)</span>
</code></pre></div>

<p>Nesse caso estamos pegando o candidato que apresenta a maior probabilidade de ser a opção correta. Essa probabilidade é basicamente a chance de uma das palavras aparecer baseado na sua frequência. Esse cálculo pode ser feito levando em consideração a quantidade de vezes que a palavra aparece, dividido pela quantidade de palavras consideradas.</p>
<p>A implementação da função de probabilidade pode ser vista abaixo.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">probability_of_word</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">VOCABULARY</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">/</span> <span class="n">TOTAL_WORDS</span>
</code></pre></div>

<p>Por fim, vamos fazer a leitura do vocabulário e do total de palavras utilizando a função <strong><code>read_vocabulary</code></strong> que definimos no início. Depois disso podemos esperar que o usuário insira a palavra, e logo em seguida devolver a correção.</p>
<div class="highlight"><pre><span></span><code><span class="n">TOTAL_WORDS</span><span class="p">,</span> <span class="n">VOCABULARY</span> <span class="o">=</span> <span class="n">read_vocabulary</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="n">misspelled_word</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;Digite a palavra incorreta: &#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Correção:&#39;</span><span class="p">,</span> <span class="n">correct</span><span class="p">(</span><span class="n">misspelled_word</span><span class="p">))</span>
</code></pre></div>

<p>Ao rodar o código completo com todas as funções necessárias, vamos ter uma execução igual ao que você pode ver abaixo.</p>
<div class="highlight"><pre><span></span><code>Digite a palavra incorreta: lgica
Correção: lógica
</code></pre></div>

<p>O código completo do nosso corretor ortográfico <a href="/docs/spell-corrector.py" target="_blank">pode ser encontrado aqui</a>. Apenas coloque o arquivo <strong><code>vocabulary.txt</code></strong> na mesma pasta do arquivo com o código.</p>
<p><a id="executando-testes"></a></p>
<h2>Executando testes</h2>
<p><a id="sugestoes-de-melhoria"></a></p>
<h2>Sugestões de melhoria</h2>
<p><a id="recapitulando"></a></p>
<h2>Recapitulando...</h2>
<p>O que aprendemos hoje:</p>
<p>Para você que acompanhou esse artigo até o final, muito obrigado pela sua atenção e até o próximo... bye bye</p>
      </div>
      <div class="back-to-top">
          <a href="#top">voltar ao topo</a>
      </div>
      <div id="disqus_thread"></div>
        <script>
        (function() {
              var d = document, s = d.createElement('script');
              s.src = 'https://lemsantos-1.disqus.com/embed.js';
              s.setAttribute('data-timestamp', +new Date());
              (d.head || d.body).appendChild(s);
        })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </article>
  </div>
<!-- end article -->
                <footer>
                    <div class="icons">
                        <a href="https://github.com/lemsantos" target="_blank"><div class="icon-github icon"></div></a>
                        <a href="https://www.linkedin.com/in/lucas-eliaquim/" target="_blank"><div class="icon-linkedin icon"></div></a>
                        <a href="mailto:lemsantos.dev@gmail.com" target="_blank"><div class="icon-mail icon"></div></a>
                    </div>
                    <p>© <script>document.write(moment().format('YYYY'));</script> Lucas Eliaquim</p>
                    <p><i>"Brutal"</i> Pelican Theme</p>
                    <p>Designed and built by <a href="http://twitter.com/mcman_s">@mcman_s</a> in Denver</p>
                </footer>
        </div>
</body>
</html>