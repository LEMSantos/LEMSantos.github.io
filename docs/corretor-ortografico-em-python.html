<!DOCTYPE html>
<html lang="pt-br">
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SW1LL2DZZ5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-SW1LL2DZZ5');
</script>
        <title>LEMSantos</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta charset="utf-8" />
        <!-- twitter card metadata -->
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="/images/avatar.webp">
<meta name="twitter:site" content="">
<meta name="twitter:title" content="Criando um corretor ortográfico simples utilizando Python">
<meta name="twitter:description" content="Nesse post vamos construir um corretor ortográfico simples utilizando Python, que apresenta, em geral, uma boa performance. Esse corretor é baseado na versão desenvolvida pelo Peter Norvig.">
        <!-- OG Tags -->
<meta property="og:url" content="/corretor-ortografico-em-python.html"/>
<meta property="og:title" content="LEMSantos | Criando um corretor ortográfico simples utilizando Python" />
<meta property="og:description" content="Nesse post vamos construir um corretor ortográfico simples utilizando Python, que apresenta, em geral, uma boa performance. Esse corretor é baseado na versão desenvolvida pelo Peter Norvig." />
        <!-- favicon -->
        <link rel="icon" type="image/png" href="/images/pelly.png">
        <!-- moment.js for date formatting -->
        <script src="/theme/js/moment.js"></script>
        <script src="/theme/js/app.js"></script>
        <script>
            moment.locale('pt-br')
        </script>
        <!-- css -->
        <link rel="stylesheet" type="text/css" href="/theme/css/main.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
		<script>

                /*! grunt-grunticon Stylesheet Loader - v2.1.2 | https://github.com/filamentgroup/grunticon | (c) 2015 Scott Jehl, Filament Group, Inc. | MIT license. */

    (function(e){function t(t,n,r,o){"use strict";function a(){for(var e,n=0;u.length>n;n++)u[n].href&&u[n].href.indexOf(t)>-1&&(e=!0);e?i.media=r||"all":setTimeout(a)}var i=e.document.createElement("link"),l=n||e.document.getElementsByTagName("script")[0],u=e.document.styleSheets;return i.rel="stylesheet",i.href=t,i.media="only x",i.onload=o||null,l.parentNode.insertBefore(i,l),a(),i}var n=function(r,o){"use strict";if(r&&3===r.length){var a=e.navigator,i=e.Image,l=!(!document.createElementNS||!document.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect||!document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image","1.1")||e.opera&&-1===a.userAgent.indexOf("Chrome")||-1!==a.userAgent.indexOf("Series40")),u=new i;u.onerror=function(){n.method="png",n.href=r[2],t(r[2])},u.onload=function(){var e=1===u.width&&1===u.height,a=r[e&&l?0:e?1:2];n.method=e&&l?"svg":e?"datapng":"png",n.href=a,t(a,null,null,o)},u.src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==",document.documentElement.className+=" grunticon"}};n.loadCSS=t,e.grunticon=n})(this);(function(e,t){"use strict";var n=t.document,r="grunticon:",o=function(e){if(n.attachEvent?"complete"===n.readyState:"loading"!==n.readyState)e();else{var t=!1;n.addEventListener("readystatechange",function(){t||(t=!0,e())},!1)}},a=function(e){return t.document.querySelector('link[href$="'+e+'"]')},c=function(e){var t,n,o,a,c,i,u={};if(t=e.sheet,!t)return u;n=t.cssRules?t.cssRules:t.rules;for(var l=0;n.length>l;l++)o=n[l].cssText,a=r+n[l].selectorText,c=o.split(");")[0].match(/US\-ASCII\,([^"']+)/),c&&c[1]&&(i=decodeURIComponent(c[1]),u[a]=i);return u},i=function(e){var t,o,a;o="data-grunticon-embed";for(var c in e)if(a=c.slice(r.length),t=n.querySelectorAll(a+"["+o+"]"),t.length)for(var i=0;t.length>i;i++)t[i].innerHTML=e[c],t[i].style.backgroundImage="none",t[i].removeAttribute(o);return t},u=function(t){"svg"===e.method&&o(function(){i(c(a(e.href))),"function"==typeof t&&t()})};e.embedIcons=i,e.getCSS=a,e.getIcons=c,e.ready=o,e.svgLoadedCallback=u,e.embedSVG=u})(grunticon,this);

                grunticon(["/theme/css/icons.data.svg.css", "/theme/css/icons.data.png.css", "/theme/css/icons.fallback.css"]);
            </script>
        <noscript><link href="/theme/css/icons.fallback.css" rel="stylesheet"></noscript>
        <!-- menu toggle javascript -->
        <script type="text/javascript">
            document.addEventListener("DOMContentLoaded", initMenu);

            function initMenu(){
                var menu = document.getElementById("menu");
                var menulink = document.getElementById("menu-link");
                menulink.addEventListener("click", function toggleMenu(){
                        window.event.preventDefault();
                        menulink.classList.toggle('active');
                        menu.classList.toggle('active');
                    });
            };
        </script>

    <meta name="description" content="Nesse post vamos construir um corretor ortográfico simples utilizando Python, que apresenta, em geral, uma boa performance. Esse corretor é baseado na versão desenvolvida pelo Peter Norvig." />

    <meta name="tags" content="Corretor ortográfico" />
    <meta name="tags" content="NLP" />
    <meta name="tags" content="Python" />

</head>
<body>
    <div role="banner" id="masthead">
        <header style="
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 266px;
            overflow-y: auto;
        ">
                <a href="/" style="
                    text-decoration: none;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                ">
                    <img
                        src="/images/avatar.webp"
                        alt="McManus Logo"
                    >

                    <h1 style="
                        margin-top: 1em;
                        font-size: 1.5em;
                        display: inline-block;
                    ">
                        Lucas Eliaquim
                    </h1>
                </a>
            <a href="#menu" id="menu-link">mais coisas</a>
            <nav id="menu" style="
                display: flex;
                flex-direction: column;
                align-items: center;
            ">
                <ul>
                        <li><a href="/pages/resume.html">Currículo</a></li>
                        <li><a href="/pages/portfolio.html">Portfólio</a></li>
                </ul>

                    <div style="
                        text-align: center;
                        margin-top: 3em;
                        font-weight: bold;
                    ">
                        Categorias
                        <hr style="width: 200px">
                    </div>

                    <ul>
                            <li><a href="/category/inteligencia-artificial.html">Inteligência Artificial</a></li>
                            <li class="active"><a href="/category/nlp.html">NLP</a></li>
                    </ul>
            </nav>
        </header>
    </div>
        <div class="page" role="main">
  <div class="article" role="article">
    <article>
        <footer>
            <a name="top"></a>
            <p>
              <time datetime=" 2022-08-20 09:29:00-03:00">
                <script>document.write(moment('2022-08-20 09:29:00-03:00').format('LL'));</script>
              </time>
            </p>
        </footer>
        <header>
          <h2>
            Criando um corretor ortográfico simples utilizando Python
          </h2>
        </header>
      <div class="content">
         <p><img alt="React: JavaScript library" src="/images/spell-checker-2.jpg"></p>
<p style="text-align: center; margin-top: -27px"><em><a href='https://br.freepik.com/fotos-vetores-gratis/ilustracao'>Ilustração vetor criado por pch.vector - br.freepik.com</a></em></p>

<p>Bom dia, Boa tarde ou Boa noite (dependendo da hora que você está lendo esse artigo), nesse post vamos tentar resolver o problema de criar um corretor ortográfico simples utilizando Python. O conteúdo desse post foi baseado em um atigo criado pelo Peter Norvig em 2007, com o título <strong><a href="https://norvig.com/spell-correct.html" target="_blank">How to Write a Spelling Corrector</a></strong>. Pensei em falar um pouco sobre isso, porque considero esse assunto muito interessante e acredito que existem outras pessoas que, como eu, pensam o mesmo.</p>
<p>O objetivo desse artigo é ajudar as pessoas que não estão tão familiarizadas com a língua inglesa, ou mesmo não entenderam muito bem o que o Norvig quis dizer. A minha ideia geral é tentar simplificar o máximo possível a parte estatística e matemática, e quem sabe simplificar um pouco do código.</p>
<p>Como eu faço sempre em meus artigos, segue uma lista de requisitos para ajudar você a aproveitar melhor o conteúdo:</p>
<ol>
<li>O primeiro requisito é ter o interpretador de Python instalado;</li>
<li>O segundo é entender o básico da linguagem Python:<ul>
<li>Variáveis e tipos de dados;</li>
<li>Estruturas de condição e repetição;</li>
<li>Funções.</li>
</ul>
</li>
</ol>
<p>Bom, agora que definimos o que precisamos, vamos começar os trabalhos. A primeira coisa que precisamos entender é como esse corretor funciona.</p>
<h2>Vá direto ao assunto...</h2>
<ul>
<li><a href="#como-o-corretor-funciona">Como o corretor funciona</a>;</li>
<li><a href="#a-implementacao">A Implementação</a>;<ul>
<li><a href="#vocabulario">Lendo o vocabulário</a>;</li>
<li><a href="#operacoes-basicas">Operações básicas</a>;</li>
<li><a href="#gerando-candidatos">Gerando candidatos</a>;</li>
<li><a href="#colocando-tudo-junto">Colocando tudo junto</a>.</li>
</ul>
</li>
<li><a href="#executando-testes">Executando testes</a>;</li>
<li><a href="#sugestoes-de-melhoria">Sugestões de melhoria</a>;</li>
<li><a href="#recapitulando">Recapitulando</a>.</li>
</ul>
<p><a id="como-o-corretor-funciona"></a></p>
<h2>Como o corretor funciona</h2>
<p>Um corretor ortográfico é uma pessoa ou programa de computador que faz a verificação de um texto ou uma palavra para achar e corrigir erros tipográficos ocasionais.</p>
<p>Na lingua portuguesa, alguns erros comuns podem acontecer quando estamos digitando. Podemos, por exemplo:</p>
<ul>
<li>Adicionar uma ou mais letras em uma palavra;</li>
<li>"Engolir" letras quando estamos digitando;</li>
<li>Trocar duas ou mais letras de uma palavra;</li>
<li>Colocar letras que não fazem parte da palavra, como por exemplo, confundir <strong>s</strong> e <strong>z</strong>.</li>
</ul>
<p>Existem outros erros que podem acontecer, porém vamos nos forcar apenas nesses quatro.</p>
<p>Sendo uma pessoa esperta, acredito que uma certa pergunta pode ter surgido na sua mente: Como fazemos para corrigir esse tipo de erro?</p>
<p>Uma forma bem intuitiva de pensar seria: Podemos gerar todas as palavras possíveis, inserindo, removendo, trocando ou colocando novas letras, e selecionar a palavra que tem a maior chance de ser a correção da palavra original. Muito bem, é exatamente o que vamos fazer. A nossa linha de pensamento pode ser dividida em quatro operações distintas:</p>
<ul>
<li>Gerar os possíveis candidatos;</li>
<li>Definir quais candidatos podem ser uma correção para a nossa palavra;</li>
<li>Definir a chance de cada candidato;</li>
<li>Escolher o candidato que tem a maior chance de ser a correção.</li>
</ul>
<p><strong>Gerar os possíveis candidatos</strong>: Vamos apenas criar variações da nossa palavra, inserindo, removendo, trocando ou colocando novas letras. Cada variação precisa ser gerada, dado que não sabemos qual é a correta.</p>
<p><strong>Definir os cadidados plausíveis</strong>: Se pensarmos bem, uma palavra de <code>N</code> letras vai ter <code>N</code> remoções, <code>N - 1</code> trocas entre as letras já existentes, <code>26N</code> trocas por novas letras e por fim <code>26(N - 1)</code> inserções, totalizando <code>54N + 25</code> variações (muitas delas podem ser duplicadas). Para uma palavra de 10 letras, ou seja <code>N=10</code>, teríamos 565 variações. Como esse número é grande, talvez uma das formas de reduzir seja eliminando as variações que não fazem parte do nosso vocabulário.</p>
<p><strong>Definir a chance de cada candidato</strong>: Para definir a chance de cada candidato precisamos saber qual a probabilidade de cada palavra aparecer em um texto. Imagino que você já deve ter pensado nisso, mas uma das formas é pegar um texto, ou vários textos e contar quantas vezes cada palavra aparece. Dessa forma, saberemos qual palavra é mais provável de aparecer.</p>
<p><strong>Escolher o candidato</strong>: Se já temos os candidatos e a chance de cada candidato de ser a correção para a palavra, só precisamos selecionar aquele que tem a maior chance.</p>
<p>Essas operações compõem as etapas que o nosso corretor precisa executar sempre que a correção de uma nova palavra for solicitada. Agora que definimos toda a linha de prensamento que precisamos, podemos partir para a implementação.</p>
<p><a id="a-implementacao"></a></p>
<h2>A implementação</h2>
<p>Podemos dividir a nossa implementação em algumas etapas. Essa divisão vai nos ajudar a entender melhor cada parte do nosso corretor. Dentre as fases, temos: a leitura do vocabulário, ou seja, a frenquência das palavras, a criação das operações básicas para gerar os candidatos, gerar de fato os candidatos e por fim, colocar tudo junto para finalizar o corretor.</p>
<p><a id="vocabulario"></a></p>
<h4>Lendo o vocabulário</h4>
<p>O nosso vocabulário vai ser basicamente um arquivo <code>.txt</code> em que vamos colocar cada palavra e sua respectiva frequência. Para ilustrar, esse arquivo vai estar no formato abaixo:</p>
<div class="highlight"><pre><span></span><code>que 15044152
não 12169729
o 12005035
de 10121551
a 8992538
é 8594955
você 7817147
e 7345808
</code></pre></div>

<p>Esse arquivo que vamos utilizar é uma contagem de palavras gerada a partir do <a href="https://www.opensubtitles.org/pt" target="_blank">OpenSubtitles</a>, que é a maior base de dados de legendas em diversas linguas. O arquivo do vocabulário <a href="/docs/vocabulary.txt" target="_blank">pode ser encontrado aqui</a>. Vamos chamá-lo de <strong><code>vocabulary.txt</code></strong>. Você pode conferir também o <a href="https://github.com/hermitdave/FrequencyWords/blob/master/content/2018/pt_br/pt_br_50k.txt">aquivo original</a> está no github.</p>
<p>Como o nosso arquivo vai ter a palavra e a respectiva frequência separadas por um espaço, podemos modelar o nosso código com os seguintes passos:</p>
<ul>
<li>Abrir o arquivo <strong><code>vocabulary.txt</code></strong>;</li>
<li>Ler o texto completo e separar cada uma das linhas;</li>
<li>Para cada linha, separar a palavra da frequência;</li>
<li>Criar um <strong><code>Counter</code></strong> para armazenar essas frequências;</li>
<li>Somar as frequências para saber o total de palavras consideradas. Vamos utilizar isso para calcular a probabilidade de cada palavra;</li>
<li>Retornar tanto a soma, quanto o <strong><code>Counter</code></strong>.</li>
</ul>
<p>O código a seguir ilustra a definição de uma função para realizar essas ações.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>


<span class="k">def</span> <span class="nf">read_vocabulary</span><span class="p">():</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;vocabulary.txt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">vocab_file</span><span class="p">:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">vocab_file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>

    <span class="n">full_vocab</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">]</span>
    <span class="n">words_counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">({</span><span class="n">word</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="k">for</span> <span class="n">word</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">full_vocab</span><span class="p">})</span>

    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">words_counter</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">words_counter</span>
</code></pre></div>

<p>O <strong><code>Counter</code></strong> é apenas uma estrutura nativa do Python para guardar frequências. É uma estrutura semelhante a um dicionário, onde teremos a palavra como chave e a frequência como valor. Algo como:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">({</span><span class="s1">&#39;que&#39;</span><span class="p">:</span> <span class="mi">15044152</span><span class="p">})</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span><span class="p">[</span><span class="s1">&#39;que&#39;</span><span class="p">]</span>
<span class="mi">15044152</span>
</code></pre></div>

<p><a id="operacoes-basicas"></a></p>
<h4>Operações básicas</h4>
<p>Agora que definimos como será a leitura do nosso vocabulário, vamos partir para as operações básicas de inserção, remoção, troca e substituição. Começameros com a função para criar candidatos a partir de inserção.</p>
<div class="highlight"><pre><span></span><code><span class="n">LETTERS</span> <span class="o">=</span> <span class="s1">&#39;abcdefghijklmnopqrstuvwxyzàáâãèéêìíîòóôõùúûç&#39;</span>

<span class="c1"># &lt;FUNÇÕES DEFINIDAS ANTERIORMENTE FICAM AQUI&gt;</span>


<span class="k">def</span> <span class="nf">generate_by_insert</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="n">generated_words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">LETTERS</span><span class="p">:</span>
            <span class="n">generated_words</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">word</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="n">letter</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">pos</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">generated_words</span>
</code></pre></div>

<p>Basicamente a função de gerar candidatos por inserção recebe a palavra como parâmetro e para cada posição inserimos cada uma das letras possíveis. Essa operação divide a palavra em duas partes, lado direito e lado esquerdo. Então ela insere entre as duas partes uma nova letra.</p>
<p>Seguindo, vamos definir a função para gerar candidatos através de remoção.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">generated_by_delete</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="n">generated_words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">generated_words</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">word</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">generated_words</span>
</code></pre></div>

<p>Mesmo esquema da função de inserção, com a diferença de retirar as letras ao invés de inserir. Essa remoção pode ser vista quando descartamos uma das letras da parte direita com o trecho <strong><code>word[pos + 1:]</code></strong>.</p>
<p>A próxima operação é para gerar candidatos através de substituição.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">generate_by_replace</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="n">generated_words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">LETTERS</span><span class="p">:</span>
            <span class="n">generated_words</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">word</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="n">letter</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">generated_words</span>
</code></pre></div>

<p>A ideia dessa operação é muito similar a de remoção, com a diferença que ao invés de descartar uma letra, colocamos outra no lugar.</p>
<p>Por último, mas não menos importante, precisamos definir uma função para gerar candidatos através de troca.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">generate_by_swap</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="n">generated_words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">generated_words</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
            <span class="n">word</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:]</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">generated_words</span>
</code></pre></div>

<p>Essa operação simplesmente troca letras dentro da própria palavra, considerando que podem existir erros de digitação onde invertemos a ordem das letras.</p>
<p>Com as operações básicas definidas, podemos finalmente partir para a geração de candidatos.</p>
<p><a id="gerando-candidatos"></a></p>
<h4>Gerando candidatos</h4>
<p>Para gerar os candidatos que servirão para corrigir a palavra, precisamos pensar que nem sempre erramos apenas uma vez quando estamos digitando uma palavra. Assim, pode ser que seja necessário criar variações onde um ou mais erros possam ser corridos. Primeiramente vamos resolver o problema de gerar os candidatos para apenas um erro, ou falando de outra forma, com distância igual a 1 em relação a palavra original.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">words_generator_1_dist</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="n">inserts</span> <span class="o">=</span> <span class="n">generate_by_insert</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
    <span class="n">deletes</span> <span class="o">=</span> <span class="n">generated_by_delete</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
    <span class="n">replaces</span> <span class="o">=</span> <span class="n">generate_by_replace</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
    <span class="n">swaps</span> <span class="o">=</span> <span class="n">generate_by_swap</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">inserts</span> <span class="o">|</span> <span class="n">deletes</span> <span class="o">|</span> <span class="n">replaces</span> <span class="o">|</span> <span class="n">swaps</span>
</code></pre></div>

<p>Nessa função, simplesmente geramos as variações baseadas em cada uma das operações e depois fazemos a união de todas elas. Assim, teremos um conjunto com todas as palavras com distância igual 1 em relação a palavra passada como parâmetro.</p>
<p>Para resolver o problema da distância igual a 2, ou seja, com a possibilidade de 2 erros sendo cometidos ao mesmo tempo, podemos definir a função como segue:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">words_generator_2_dist</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="n">words_2_dist</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">new_word</span> <span class="ow">in</span> <span class="n">words_generator_1_dist</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
        <span class="n">words_2_dist</span> <span class="o">|=</span> <span class="n">words_generator_1_dist</span><span class="p">(</span><span class="n">new_word</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">words_2_dist</span>
</code></pre></div>

<p>Basicamente estamos considerando que, se para cada palavra com distância igual a 1, gerarmos outra palavra com distância igual a 1, conseguimos gerar palavras com distância total igual a 2 em relação a palavra original.</p>
<p>Podemos continuar gerando palavras com mais distâncias para cobrir a maior quantidade possível de erros, porém para cada nova possibilidade que pensamos, a quantidade de palavras aumenta vertiginosamente. Dessa forma, em algum momento podemos não conseguir mais lidar com a quantidade imensa de palavras e acabar eliminando a eficiência do nosso corretor.</p>
<p>Você vai ver que para a grande maioria dos casos, a distância máxima igual a 2 já é o suficiente.</p>
<p>Bom, agora que definimos funções auxiliares para gerar as variações das palavras, podemos enfim selecionar os candidatos mais adequados.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">candidates</span><span class="p">(</span><span class="n">misspelled_word</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">known_words</span><span class="p">({</span><span class="n">misspelled_word</span><span class="p">})</span> <span class="ow">or</span>
            <span class="n">known_words</span><span class="p">(</span><span class="n">words_generator_1_dist</span><span class="p">(</span><span class="n">misspelled_word</span><span class="p">))</span> <span class="ow">or</span>
            <span class="n">known_words</span><span class="p">(</span><span class="n">words_generator_2_dist</span><span class="p">(</span><span class="n">misspelled_word</span><span class="p">))</span> <span class="ow">or</span>
            <span class="p">{</span><span class="n">misspelled_word</span><span class="p">})</span>
</code></pre></div>

<p>Para definir quem é um candidato adequado, precisamos definir um modelo de seleção. Como não temos nenhum banco de erros ortográficos para analisar, podemos pensar em algumas regrinhas simples.</p>
<ul>
<li>Se a palavra que foi passada para ser corrigida já existe no nosso vocabulário, então provavelmente ela não precisa ser corrigida. Retornamos ela;</li>
<li>Ou se, ao gerar variações considerando a distância igual a 1 encontrarmos palavras existentes no vocabulário, então provavelmente elas são os candidatos corretos;</li>
<li>Ou se, ao gerar variações considerando a distância igual a 2 encontrarmos palavras existentes no vocabulário, então provavelmente elas são os candidatos corretos;</li>
<li>Se não, retornamos a própria palavra que foi passada, dado que não encontramos correção para ela.</li>
</ul>
<p>Nesse caso estamos levando em consideração que errar apenas uma vez é mais provável do que errar duas vezes.</p>
<p>Apenas uma coisa faltou, definir a função <strong><code>known_words</code></strong>, que nos retorna quais palavras de um conjunto estão presentes no nosso vocabulário.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">known_words</span><span class="p">(</span><span class="n">words_set</span><span class="p">):</span>
    <span class="n">vocabulary_words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">VOCABULARY</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">words_set</span> <span class="o">&amp;</span> <span class="n">vocabulary_words</span>
</code></pre></div>

<p>A variável <strong><code>VOCABULARY</code></strong> será definida posteriormente.</p>
<p><a id="colocando-tudo-junto"></a></p>
<h4>Colocando tudo junto</h4>
<p>Agora que temos todas as funções necessárias para efetuar a correção, podemos enfim definir a função que de fato faz isto.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">correct</span><span class="p">(</span><span class="n">misspelled_word</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">candidates</span><span class="p">(</span><span class="n">misspelled_word</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">probability_of_word</span><span class="p">)</span>
</code></pre></div>

<p>Nesse caso estamos pegando o candidato que apresenta a maior probabilidade de ser a opção correta. Essa probabilidade é basicamente a chance de uma das palavras aparecer baseado na sua frequência. Esse cálculo pode ser feito levando em consideração a quantidade de vezes que a palavra aparece, dividido pela quantidade de palavras consideradas.</p>
<p>A implementação da função de probabilidade pode ser vista abaixo.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">probability_of_word</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">VOCABULARY</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">/</span> <span class="n">TOTAL_WORDS</span>
</code></pre></div>

<p>Por fim, vamos fazer a leitura do vocabulário e do total de palavras utilizando a função <strong><code>read_vocabulary</code></strong> que definimos no início. Depois disso podemos esperar que o usuário insira a palavra, e logo em seguida devolver a correção.</p>
<div class="highlight"><pre><span></span><code><span class="n">TOTAL_WORDS</span><span class="p">,</span> <span class="n">VOCABULARY</span> <span class="o">=</span> <span class="n">read_vocabulary</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="n">misspelled_word</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;Digite a palavra incorreta: &#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Correção:&#39;</span><span class="p">,</span> <span class="n">correct</span><span class="p">(</span><span class="n">misspelled_word</span><span class="p">))</span>
</code></pre></div>

<p>Ao rodar o código completo com todas as funções necessárias, vamos ter uma execução igual ao que você pode ver abaixo.</p>
<div class="highlight"><pre><span></span><code>Digite a palavra incorreta: lgica
Correção: lógica
</code></pre></div>

<p>O código completo do nosso corretor ortográfico <a href="/docs/spell-corrector.py" target="_blank">pode ser encontrado aqui</a>. Apenas coloque o arquivo <strong><code>vocabulary.txt</code></strong> na mesma pasta do arquivo com o código.</p>
<p><a id="executando-testes"></a></p>
<h2>Executando testes</h2>
<p>Tendo o nosso corretor ortográfico finalizado, precisamos saber se ele possui uma boa performance. Para executar esse teste vamos precisar de uma banco de dados de palavras incorretas, assim como a sua correção. Assim, podemos verificar algumas coisas interessantes:</p>
<ul>
<li><strong>Acurácia</strong>: Quanto de acerto o nosso corretor possui em relação às palavras de teste;</li>
<li><strong>Eficiência</strong>: Quantas palavras conseguimos corrigir em um determinado período de tempo, no caso, segundos;</li>
<li><strong>Palavras desconhecidas</strong>: Quanto do erro do nosso corretor é devido a palavras que ele não conhece, ou seja, não estão presentes no vocabulário.</li>
</ul>
<p>Segue abaixo o código utilizado para executar os testes mencionados acima. O arquivo com as palavras incorretas e corretas que foi utilizado como conjunto de testes <a href="/docs/misspelled.txt" target="_blank">pode ser encontrado aqui</a>. Esse arquivo é baseado na <a href="https://pt.wikipedia.org/wiki/Wikip%C3%A9dia:Lista_de_erros_comuns/M%C3%A1quinas" target="_blank">lista de erros comuns</a> disponibilizada pela Wikipédia.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">main</span> <span class="kn">import</span> <span class="n">correct</span><span class="p">,</span> <span class="n">VOCABULARY</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span>


<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;misspelled.txt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">test_file</span><span class="p">:</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">test_file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>

<span class="n">words</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">]</span>

<span class="n">hits</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">begin</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
<span class="k">for</span> <span class="n">wrong</span><span class="p">,</span> <span class="n">true</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
    <span class="n">hits</span> <span class="o">+=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">correct</span><span class="p">(</span><span class="n">wrong</span><span class="p">)</span> <span class="o">==</span> <span class="n">true</span> <span class="k">else</span> <span class="mi">0</span>
<span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>

<span class="n">accuracy</span> <span class="o">=</span> <span class="n">hits</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>
<span class="n">efficiency</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">begin</span><span class="p">)</span>
<span class="n">unknown</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">word</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">VOCABULARY</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Acurácia = </span><span class="si">%.2f%%</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">accuracy</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Eficiência = </span><span class="si">%d</span><span class="s1"> palavras/segundo&#39;</span> <span class="o">%</span> <span class="n">efficiency</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Palavras desconhecidas = </span><span class="si">%.2f%%</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">unknown</span> <span class="o">*</span> <span class="mi">100</span><span class="p">))</span>
</code></pre></div>

<p>Ao executar esse teste, considerando que todos os arquivos de código estão na mesma pasta, vamos ver mensagens muito próximas das encontradas abaixo.</p>
<div class="highlight"><pre><span></span><code>Acurácia = 57.58%
Eficiência = 4 palavras/segundo
Palavras desconhecidas = 17.97%
</code></pre></div>

<p>A primeira vista podemos constatar que a nossa acurácia não está tão boa. Isso pode ter acontecido levando em consideração que o nosso modelo para selecionar os melhores candidatos é muito trivial.</p>
<p>Outra coisa interessante de observar é a eficiência. Ela está muito baixa, por isso, talvez seja interessante pensar em algumas otimizações para o nosso código.</p>
<p>Por último, mas não menos importante, podemos observar as palavras desconhecidas. Se pensarmos bem, é possível que o corretor não conheça muitas das plavras da língua portuguesa. A língua é muito extensa, com bem mais do que 300 mil palavras. O nosso vocabulário possui apenas 50 mil dessas palavras, e como ele foi feito utilizando textos não revisados, é possível que ainda existam palavras incorretas nele, ainda que possuam uma frequência mais baixa.</p>
<p><a id="sugestoes-de-melhoria"></a></p>
<h2>Sugestões de melhoria</h2>
<p>Verificamos através dos testes que temos alguns pontos interessantes de melhoria, que podemos aplicar no nosso corretor. São eles:</p>
<h4>1. Otimizar o código</h4>
<p>Uma otimização importante que pode ser feita, é modificar todos os loop que geraram conjuntos para utilizar o <a href="https://python-reference.readthedocs.io/en/latest/docs/comprehensions/set_comprehension.html" target="_blank">Set Comprehension</a>. Podemos, por exemplo, modificar o código de geração de cadidatos de inserção:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">generate_by_insert</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="n">generated_words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">LETTERS</span><span class="p">:</span>
            <span class="n">generated_words</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">word</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="n">letter</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">pos</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">generated_words</span>
</code></pre></div>

<p>por essa outra abordagem:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">generate_by_insert</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="n">word</span><span class="p">[:</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="n">letter</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">pos</span><span class="p">:]</span>
        <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">LETTERS</span>
    <span class="p">}</span>
</code></pre></div>

<p>Só com essa alteração, feita em todo o código, é possível dobrar a eficiência do corretor. A primeira abordagem foi utilizada ao longo de todo o artigo, para facilitar o entendimento.</p>
<p>Outras otimizações ainda podem ser elaboradas, mas deixo isso como dever de casa para você.</p>
<h4>2. Melhorar o vocabulário do corretor</h4>
<p>Ficou bem claro, com o resultado do teste, que palavras desconhecidas podem ser um problema para o corretor. Se a correção da palavra não existe no vocabulário, nunca será possível produzir o resultado desejado. Nós podemos construir um vocabulário melhor apenas coletando mais dados.</p>
<p>Outra forma de lidar com palavras desconhecidas, é permitindo que o corretor possa produzir um resultado que não existe no vocabulário. Podemos considerar utilizar regras mais simples para gerar candidatos plausíveis, como por exemplo, substituir <code>s</code> por <code>z</code> ou <code>ç</code> por <code>ss</code>, mesmo que a palavra resultante não exista no vocabulário. Assim, a ideia geral é utilizar regras presentes na língua portuguesa para suprir a deficiência da base de conhecimento do corretor.</p>
<h4>3. Considerar o contexto das palavras</h4>
<p>Essa, provavelmente, é a melhor forma de aperfeiçoar a performance do corretor. Para realizar essa melhoria, precisamos utilizar uma técnica que ainda não vimos, o <strong>N-grama</strong>.</p>
<p>Um N-grama é uma sequência contínua de <em>N</em> items de uma determinada amostra de texto ou fala. Ficou confuso? Eu explico melhor.</p>
<p>Imagine que podemos considerar apenas a probabilidade da palavra <strong><code>de</code></strong> aparecer em um diálogo. Sabemos por exemplo que ela pode aparecer em 30% das vezes. Mas, se eu te disser que antes dela existe a palavra <strong><code>corte</code></strong> e depois dela existe a palavra <strong><code>cabelo</code></strong>, qual a probabilidade da frase <strong><code>corte de cabelo</code></strong> aparecer em um diálogo?</p>
<p>A frase <strong><code>corte de cabelo</code></strong> é um exemplo de N-grama, onde <em>N</em> é igual a 3. Assim com a informação de que a frase <strong><code>corte de cabelo</code></strong> aparece, por exemplo, 3% das vezes em um diálogo, temos a possibilidade de corrigir a frase <strong><code>corte di cabelo</code></strong>, onde podemos nos perguntar o seguinte:</p>
<p>Dado que as palavras <strong><code>corte</code></strong> e <strong><code>cabelo</code></strong> apareceram antes e depois da palavra <strong><code>di</code></strong>, qual é a chance da correção ser a palavra <strong><code>de</code></strong>?</p>
<p>Com essa linha de pensamento passamos a considerar o contexto das conversações, mesmo que esse contexto seja limitado. O número ideal para o <em>N</em> é definido experimentalmente e pode variar de acordo com os dados. Quanto maior o número de <em>N</em> maior será o nosso vocabulário e consequentemente mais operações o nosso corretor terá que fazer.</p>
<p>Fica como tarefinha para casa tentar implementar essa melhoria, apenas considerando o contexto o seu corretor ortográfico tem o potencial de acertar a correção de muito mais palavras.</p>
<h4>4. Implementar em uma linguagem compilada</h4>
<p>Finalmente, é possível otimizar a implementação tornando ela muito mais rápida, sem mudar os resultados. Podemos simplesmente refazer o código utilizando uma linguagem compilada ao invés de uma linguagem interpretada, como é o caso do Python. Implementar utilizando linguagens como C ou C++ pode aumentar muitas vezes a eficiência do corretor.</p>
<p>O próprio artigo do Peter Norvig, citado no início, traz diversos exemplos de implementações utilizando outras linguagens, como Go, Erlang, Clojure, Haskell, etc. Vale a pena dar uma conferida.</p>
<p><a id="recapitulando"></a></p>
<h2>Recapitulando...</h2>
<p>O que aprendemos hoje:</p>
<ul>
<li>Entendemos como o corretor proposto pelo Peter Norvig funciona;</li>
<li>Implementamos uma versão dele utilizando Python;</li>
<li>Executamos testes para descobrir quão eficiente é esse corretor em cenários reais;</li>
<li>Vimos que existem melhorias que podem ser feitas para que o corretor performe melhor.</li>
</ul>
<p>O corretor que implementamos, é uma versão bem simplificada em relação ao que existe no mercado hoje. Algumas empresas utilizam, inclusive, modelos de Machine Learning para melhorar a acurácia das correções. Ainda que simples, o nosso corretor pode ser aplicado em cenários reais, mesmo que necessite de uma atenção especial na hora de construir o nosso vocabulário e implementar algumas melhorias.</p>
<p>Para você que acompanhou esse artigo até o final, muito obrigado pela sua atenção e até o próximo... bye bye</p>
      </div>
      <div class="back-to-top">
          <a href="#top">voltar ao topo</a>
      </div>
      <div id="disqus_thread"></div>
        <script>
        (function() {
              var d = document, s = d.createElement('script');
              s.src = 'https://lemsantos-1.disqus.com/embed.js';
              s.setAttribute('data-timestamp', +new Date());
              (d.head || d.body).appendChild(s);
        })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </article>
  </div>
<!-- end article -->
                <footer>
                    <div class="icons">
                        <a href="https://github.com/lemsantos" target="_blank"><div class="icon-github icon"></div></a>
                        <a href="https://www.linkedin.com/in/lucas-eliaquim/" target="_blank"><div class="icon-linkedin icon"></div></a>
                        <a href="mailto:lemsantos.dev@gmail.com" target="_blank"><div class="icon-mail icon"></div></a>
                    </div>
                    <p>© <script>document.write(moment().format('YYYY'));</script> Lucas Eliaquim</p>
                    <p><i>"Brutal"</i> Pelican Theme</p>
                    <p>Designed and built by <a href="http://twitter.com/mcman_s">@mcman_s</a> in Denver</p>
                </footer>
        </div>
</body>
</html>