<!DOCTYPE html>
<html lang="pt-br">
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SW1LL2DZZ5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-SW1LL2DZZ5');
</script>
        <title>LEMSantos</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta charset="utf-8" />
        <!-- twitter card metadata -->
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="/images/avatar.webp">
<meta name="twitter:site" content="">
<meta name="twitter:title" content="Entendendo o algoritmo Minimax com o Jogo da Velha">
<meta name="twitter:description" content="Nesse artigo vamos aprender a construir o algorítimo minimax para jogar o jogo da velha, e além disso, vamos aprender como otimizar a abordagem ingênua através da poda alfa-beta e da utilização de heurísticas.">
        <!-- OG Tags -->
<meta property="og:url" content="/jogo-da-velha-utilizando-minimax.html"/>
<meta property="og:title" content="LEMSantos | Entendendo o algoritmo Minimax com o Jogo da Velha" />
<meta property="og:description" content="Nesse artigo vamos aprender a construir o algorítimo minimax para jogar o jogo da velha, e além disso, vamos aprender como otimizar a abordagem ingênua através da poda alfa-beta e da utilização de heurísticas." />
        <!-- favicon -->
        <link rel="icon" type="image/png" href="/images/pelly.png">
        <!-- moment.js for date formatting -->
        <script src="/theme/js/moment.js"></script>
        <script src="/theme/js/app.js"></script>
        <script>
            moment.locale('pt-br')
        </script>
        <!-- css -->
        <link rel="stylesheet" type="text/css" href="/theme/css/main.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
		<script>

                /*! grunt-grunticon Stylesheet Loader - v2.1.2 | https://github.com/filamentgroup/grunticon | (c) 2015 Scott Jehl, Filament Group, Inc. | MIT license. */

    (function(e){function t(t,n,r,o){"use strict";function a(){for(var e,n=0;u.length>n;n++)u[n].href&&u[n].href.indexOf(t)>-1&&(e=!0);e?i.media=r||"all":setTimeout(a)}var i=e.document.createElement("link"),l=n||e.document.getElementsByTagName("script")[0],u=e.document.styleSheets;return i.rel="stylesheet",i.href=t,i.media="only x",i.onload=o||null,l.parentNode.insertBefore(i,l),a(),i}var n=function(r,o){"use strict";if(r&&3===r.length){var a=e.navigator,i=e.Image,l=!(!document.createElementNS||!document.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect||!document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image","1.1")||e.opera&&-1===a.userAgent.indexOf("Chrome")||-1!==a.userAgent.indexOf("Series40")),u=new i;u.onerror=function(){n.method="png",n.href=r[2],t(r[2])},u.onload=function(){var e=1===u.width&&1===u.height,a=r[e&&l?0:e?1:2];n.method=e&&l?"svg":e?"datapng":"png",n.href=a,t(a,null,null,o)},u.src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==",document.documentElement.className+=" grunticon"}};n.loadCSS=t,e.grunticon=n})(this);(function(e,t){"use strict";var n=t.document,r="grunticon:",o=function(e){if(n.attachEvent?"complete"===n.readyState:"loading"!==n.readyState)e();else{var t=!1;n.addEventListener("readystatechange",function(){t||(t=!0,e())},!1)}},a=function(e){return t.document.querySelector('link[href$="'+e+'"]')},c=function(e){var t,n,o,a,c,i,u={};if(t=e.sheet,!t)return u;n=t.cssRules?t.cssRules:t.rules;for(var l=0;n.length>l;l++)o=n[l].cssText,a=r+n[l].selectorText,c=o.split(");")[0].match(/US\-ASCII\,([^"']+)/),c&&c[1]&&(i=decodeURIComponent(c[1]),u[a]=i);return u},i=function(e){var t,o,a;o="data-grunticon-embed";for(var c in e)if(a=c.slice(r.length),t=n.querySelectorAll(a+"["+o+"]"),t.length)for(var i=0;t.length>i;i++)t[i].innerHTML=e[c],t[i].style.backgroundImage="none",t[i].removeAttribute(o);return t},u=function(t){"svg"===e.method&&o(function(){i(c(a(e.href))),"function"==typeof t&&t()})};e.embedIcons=i,e.getCSS=a,e.getIcons=c,e.ready=o,e.svgLoadedCallback=u,e.embedSVG=u})(grunticon,this);

                grunticon(["/theme/css/icons.data.svg.css", "/theme/css/icons.data.png.css", "/theme/css/icons.fallback.css"]);
            </script>
        <noscript><link href="/theme/css/icons.fallback.css" rel="stylesheet"></noscript>
        <!-- menu toggle javascript -->
        <script type="text/javascript">
            document.addEventListener("DOMContentLoaded", initMenu);

            function initMenu(){
                var menu = document.getElementById("menu");
                var menulink = document.getElementById("menu-link");
                menulink.addEventListener("click", function toggleMenu(){
                        window.event.preventDefault();
                        menulink.classList.toggle('active');
                        menu.classList.toggle('active');
                    });
            };
        </script>

    <meta name="description" content="Nesse artigo vamos aprender a construir o algorítimo minimax para jogar o jogo da velha, e além disso, vamos aprender como otimizar a abordagem ingênua através da poda alfa-beta e da utilização de heurísticas." />

    <meta name="tags" content="Minimax" />
    <meta name="tags" content="Python" />
    <meta name="tags" content="Busca" />
    <meta name="tags" content="Inteligência Artificial" />

</head>
<body>
    <div role="banner" id="masthead">
        <header style="
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 266px;
            overflow-y: auto;
        ">
                <a href="/" style="
                    text-decoration: none;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                ">
                    <img
                        src="/images/avatar.webp"
                        alt="McManus Logo"
                    >

                    <h1 style="
                        margin-top: 1em;
                        font-size: 1.5em;
                        display: inline-block;
                    ">
                        Lucas Eliaquim
                    </h1>
                </a>
            <a href="#menu" id="menu-link">mais coisas</a>
            <nav id="menu" style="
                display: flex;
                flex-direction: column;
                align-items: center;
            ">
                <ul>
                        <li><a href="/pages/resume.html">Currículo</a></li>
                        <li><a href="/pages/portfolio.html">Portfólio</a></li>
                </ul>

                    <div style="
                        text-align: center;
                        margin-top: 3em;
                        font-weight: bold;
                    ">
                        Categorias
                        <hr style="width: 200px">
                    </div>

                    <ul>
                            <li class="active"><a href="/category/inteligencia-artificial.html">Inteligência Artificial</a></li>
                            <li><a href="/category/nlp.html">NLP</a></li>
                    </ul>
            </nav>
        </header>
    </div>
        <div class="page" role="main">
  <div class="article" role="article">
    <article>
        <footer>
            <a name="top"></a>
            <p>
              <time datetime=" 2022-07-27 09:03:00-03:00">
                <script>document.write(moment('2022-07-27 09:03:00-03:00').format('LL'));</script>
              </time>
              &nbsp;&nbsp;•&nbsp;&nbsp;
              <span id="reading-time-container">
                <script>
                  document.addEventListener('DOMContentLoaded', function() {
                    var wordsPerMinute = 200;

                    var content = [...document.querySelectorAll('.content p, .content ul')].map((e) => e.textContent)
                    content = content.join(' ');

                    var words = [
                      ...content.matchAll(/[a-zA-Z\u00C0-\u024F\u1E00-\u1EFF]+/g)
                    ].map((w) => w[0]);

                    var readingTime = Math.trunc(words.length / 200);

                    document.getElementById("reading-time-container").innerHTML = `${readingTime} min de leitura`;
                  }, false);
                </script>
              <span>
            </p>
        </footer>
        <header>
          <h2>
            Entendendo o algoritmo Minimax com o Jogo da Velha
          </h2>

          <footer>
            <p>

            </p>
          </footer>
        </header>
      <div class="content">
         <p><img alt="Imagem do bot jogando o jogo da velha" src="/images/tictactoe.png"></p>
<p style="text-align: center; margin-top: -27px"><em><a href="https://www.freepik.com/vectors/robot-chatbot" target="_blank">Robot chatbot vector created by upklyak - www.freepik.com</a></em></p>

<p>Bom dia, Boa tarde ou Boa noite (dependendo da hora que você está lendo esse artigo), nesse post vamos entender um pouco melhor o algoritmo Minimax. Vamos também ver como ele funciona com um exemplo prático de aplicação ao jogo da velha.</p>
<p>Antes de tudo, para que você possa aproveitar melhor o centeúdo, é interessante que você tenha o interpretador de Python instalado no seu computador e entenda:</p>
<ol>
<li>O básico da linguagem Python:<ul>
<li>Variáveis e tipos de dados</li>
<li>Estruturas de condição e repetição</li>
<li>Funções</li>
</ul>
</li>
<li>Sobre recursividade e como funciona</li>
<li>O básico sobre árvores e estrutura de dados</li>
</ol>
<p>Se interessou? Pois, segue o fio e vamos em frente porque atrás vem gente.</p>
<h2>Vá direto ao assunto...</h2>
<ul>
<li><a href="#preparando-o-jogo-da-velha">Preparando o jogo da velha</a></li>
<li><a href="#o-minimax">O Minimax</a><ul>
<li><a href="#implementando-a-abordagem-ingenua">Implementando a abordagem ingênua</a></li>
<li><a href="#otimizando-com-a-poda-alfa-beta">Otimizando com a poda Alfa-Beta</a></li>
<li><a href="#aprimorando-ainda-mais-com-heuristicas">Aprimorando ainda mais com heurísticas</a></li>
</ul>
</li>
<li><a href="#recapitulando">Recapitulando</a></li>
</ul>
<p><a id="preparando-o-jogo-da-velha"></a></p>
<h2>Preparando o jogo da velha</h2>
<p>O jogo da velha, cerquilha, jogo do galo ou tic-tac-toe é um jogo/passatempo muito popular (joguei muito quando era pequeno). Ele possui regras bem simples. A ideia geral é que tendo um tabuleiro 3 x 3, cada jogador escolhe um símbolo, tipicamente "X" ou "O", e cada um dele faz uma jogada por turno. O jogador que conseguir colocar 3 símbolos iguais em linha, coluna ou diagonal vence o jogo. Caso isso não seja possível e as jogadas se esgotem, o jogo acaba em empate.</p>
<p>Bom, para que possamos implementar o nosso algoritmo invencível no jogo da velha, precisamos primeiro ter um jogo da velha (hehehehe). Então, vamos contruir uma versão bem simples utilizando Python e deixá-lo pronto para que possamos enfrentar o computador.</p>
<p>Vamos precisar de algumas funções úteis:</p>
<ul>
<li>Função para verificar se um determinado jogador venceu</li>
<li>Função para verificar se houve empate</li>
<li>Função para verificar se o jogo acabou</li>
<li>Por último, uma função para imprimir na tela o nosso tabuleiro</li>
</ul>
<p>Após implementar-mos essas funções é só montar a lógica do nosso jogo.</p>
<p>Vamos começar com a função para determinar um vencedor:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">is_win</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">player</span><span class="p">):</span>
    <span class="c1"># Verificando as Linhas do Tabuleiro</span>
    <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># Verificando as Colunas do Tabuleiro</span>
    <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># Verificando as Diagonais do Tabuleiro</span>
    <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">player</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>
</code></pre></div>

<p>Eu sei que tem muitos IFs, mas eu tentei fazer da forma mais didática possível para facilitar o entendimento. Basicamente estamos verificando todas as linhas, colunas e diagornais, para checar se o <strong><code>player</code></strong> formou uma sequência. Em caso positivo retornamos <strong><code>True</code></strong>, e <strong><code>False</code></strong> caso contrário.</p>
<p>Em seguida precisamos verificar o empate:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">is_draw</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">board</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39; &#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="kc">True</span>
</code></pre></div>

<p>Para definir se houve empate ou não, basta ver todas as linha, se houver algum espaço em branco significa que o jogo ainda não acabou. Em seguida vamos definir uma função para verificar se o jogo foi finalizado:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">is_terminal</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_win</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">CPU_PLAYER</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_win</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">HUMAN_PLAYER</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_draw</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>
</code></pre></div>

<p>Essa função vai nos ajudar a simplificar o nosso código e também vai ser útil quando estivermos implementando o Minimax. Ainda não se preocupe com as variáveis <strong><code>CPU_PLAYER</code></strong> e <strong><code>HUMAN_PLAYER</code></strong>, elas serão definidas em outro momento, apenas pense nelas como o símbolo que identifica cada jogador, no nosso caso <strong><code>X</code></strong> e <strong><code>O</code></strong>.</p>
<p>Por último, mas não menos importante, precisamos da função que vai desenhar o nosso tabuleiro:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">print_board</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">line</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39; | &#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--+---+--&#39;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</code></pre></div>

<p>Com as funções necessárias já finalizadas, agora podemos montar a nossa lógica de jogo.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randint</span>

<span class="c1"># ...</span>
<span class="c1"># AQUI FICARIAM AS OUTRAS FUNÇÔES</span>
<span class="c1"># ...</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">CPU_PLAYER</span> <span class="o">=</span> <span class="s1">&#39;X&#39;</span>
    <span class="n">HUMAN_PLAYER</span> <span class="o">=</span> <span class="s1">&#39;O&#39;</span>

    <span class="n">human_play_first</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;Você deseja começar o jogo [s|n]: &#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span>

    <span class="k">if</span> <span class="n">human_play_first</span><span class="p">:</span>
        <span class="n">HUMAN_PLAYER</span> <span class="o">=</span> <span class="s1">&#39;X&#39;</span>
        <span class="n">CPU_PLAYER</span> <span class="o">=</span> <span class="s1">&#39;O&#39;</span>

    <span class="n">board</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">],</span>
             <span class="p">[</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">],</span>
             <span class="p">[</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">]]</span>

    <span class="k">while</span> <span class="ow">not</span> <span class="n">is_terminal</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">human_play_first</span><span class="p">:</span>
            <span class="n">print_board</span><span class="p">(</span><span class="n">board</span><span class="p">)</span>

            <span class="n">position</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s1">&#39;Insira a posição da jogada [1-9]: &#39;</span><span class="p">))</span>

            <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">position</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3</span>
            <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">position</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>

            <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">HUMAN_PLAYER</span>

            <span class="k">if</span> <span class="n">is_terminal</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>
                <span class="k">break</span>

        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39; &#39;</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">CPU_PLAYER</span>
        <span class="n">human_play_first</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">print_board</span><span class="p">(</span><span class="n">board</span><span class="p">)</span>
</code></pre></div>

<p>Com a lógica de jogo finalizada, sinta-se a vontade para testar. Nessa parte, enquanto não temos o nosso algoritmo inteligente, fazemos o computador realizar jogadas aleatórias com o trecho:</p>
<div class="highlight"><pre><span></span><code><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="k">while</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39; &#39;</span><span class="p">:</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">CPU_PLAYER</span>
</code></pre></div>

<p>Se for da sua preferência você ainda pode colocar um trecho, após a última função <strong><code>print_board</code></strong>, para entregar uma mensagem amigável ao usuário, como ilustrado abaixo.</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span> <span class="n">is_win</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">HUMAN_PLAYER</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Você venceu!!&#39;</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">is_win</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">CPU_PLAYER</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Você perdeu!!&#39;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Deu Empate!!&#39;</span><span class="p">)</span>
</code></pre></div>

<p>O código completo dessa parte do jogo da velha você pode encontrar <a href="/docs/tic-tac-toe.py" target="_blank">nesse link</a>.</p>
<p>Bom, código implementado e tudo funcional, está na hora de pensar em deixar o nosso computador um pouco mais inteligente.</p>
<p><a id="o-minimax"></a></p>
<h2>O Minimax</h2>
<p>O Minimax é um algoritmo baseado em árvore que trabalha de forma recursiva e é utilizado em teoria da decisão e teoria dos jogos. Ele fornece um movimento ótimo para o jogador, considerando que o oponente também joga de forma ótima. Ele geralmente é utilizado para implementar IA em jogos, como Xadrez, Jogo da Velha, e vários outros jogos de dois jogadores.</p>
<p>O Minimax intuitivamente constrói uma árvore para a tomada de decisão levando em consideração todas as jogadas possíveis. Essa árvore muitas vezes é difícil de ser percebida, dado que ela é feita através de recursividade, onde muita abstração é necessária.</p>
<p>Todos os nossos exemplos de utilização do Minimax vão levar em consideração o jogo da velha.</p>
<p>Imagine a seguinte situação, o seu nome é <strong>MAX</strong> e o seu oponente se chama <strong>MIN</strong>. Você está em um jogo bem complicado e é a sua vez. Uma forma comum de pensar seria: Se eu, MAX jogar na posição x, o MIN pode jogar em y ou z, e dai então eu...</p>
<p>Esse tipo de pensamento pode ser modelado como uma árvore de decisão como visto abaixo.</p>
<p><img alt="Árvore gerada pelo Minimax" src="/images/minimax-tree.png" width="75%"></p>
<p>Olhando dessa forma, podemos escolher uma jogada e saber exatamente quais as consequências dessa escolha.</p>
<p>Agora precisamos de alguma forma identificar onde o jogo termina e atribuir uma pontuação adequada. No nosso caso vamos colocar <strong><code>+1</code></strong> sempre que o <strong><code>MAX</code></strong> vencer, <strong><code>-1</code></strong> para o caso de vitória do <strong><code>MIN</code></strong> e <strong><code>0</code></strong> no empate. Essas pontuações podem ser alteradas, mas é importante de alguma forma fazer com que a vitória seja mais vantajosa que a derrota. Assim, para representar essa importância colocamos números positivos, negativos e neutros, introduzindo então, uma lógica matemática.</p>
<p><img alt="Árvore gerada pelo Minimax com pontuação nas folhas" src="/images/minimax-tree-punctuation.png" width="75%"></p>
<p>No caso do nosso exemplo não tivemos situações de empate, mas é importante sempre lembrar de colocar todas as pontuações corretas.</p>
<p>Agora vamos propagar a nossa pontuação para os estados superiores para saber qual é a melhor jogada para escolher. Pense agora que sempre que o <strong><code>MAX</code></strong> vai fazer a jogada ele quer maximizar as suas chances e por isso sempre escolhemos a maior pontuação para ser propagada. Já no caso da jogada do <strong><code>MIN</code></strong>, ele quer minimizar as chances do <strong><code>MAX</code></strong> e assim sempre escolhe a menor pontuação a ser propagada.</p>
<p><img alt="Árvore gerada pelo Minimax com propagação da pontuação" src="/images/minimax-tree-propagation.png" width="75%"></p>
<p>Agora o <strong><code>MAX</code></strong> tem 3 possibilidades de escolha, uma com pontuação <strong><code>+1</code></strong> e duas com <strong><code>-1</code></strong>. Como o <strong><code>MAX</code></strong> é esperto e quer sempre escolher a melhor jogada possível, a jogada escolhida será a demonstrada abaixo. Assim, como consequência dessa escolha, o <strong><code>MAX</code></strong> vence o jogo.</p>
<p><img alt="Jogada vencedora escolhida" src="/images/win-strategy.png" width="25%"></p>
<p>Seguindo esse exemplo nós acabamos de definir o comportamento esperado do Minimax.</p>
<p>Sendo uma pessoa esperta, imagino que você deve ter notado que se em algum estado a pontuação estiver negativa, significa que em algum momento na subárvore existe pelo menos uma possibilidade de derrota. Deve ter percebido também que só é interessante seguir esse caminho quando não temos nenhuma opção melhor como uma vitória ou um empate. De forma análoga, se existe um ramo com pontuação positiva, significa que naquela subárvore existe 100% de chance de vitória.</p>
<p>Com a lógica de funcionamento já definida, podemos enfim tentar implementar esse algoritmo no nosso jogo.</p>
<p><a id="implementando-a-abordagem-ingenua"></a></p>
<h3>Implementando a abordagem ingênua</h3>
<p>Como você deve ter notado, o algoritmo precisa sempre gerar as jogadas candidatas a partir de um estado inicial. Sendo assim, esse é um bom ponto de partida para a nossa implementação. Abaixo segue a implementação de uma função para gerar esses candidatos.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

<span class="c1"># ...</span>
<span class="c1"># FUNÇÔES ANTERIORES FICAM AQUI</span>
<span class="c1"># ...</span>


<span class="k">def</span> <span class="nf">candidates</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">player</span><span class="p">):</span>
    <span class="n">candidate_moves</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39; &#39;</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">candidate</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">board</span><span class="p">)</span>
            <span class="n">candidate</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">player</span>

            <span class="n">candidate_moves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">candidate_moves</span>
</code></pre></div>

<p>O que fazemos é, para cada posição livre no tabuleiro, criamos uma cópia desse tabuleiro e ocupamos a próxima posição possível. Com isso criamos uma lista de possíveis movimentos a partir de um estado inicial que foi passado para a função.</p>
<p>Em seguida precisamos de uma função para avaliar os nosso estados finais, ou seja, os estados onde o jogo acabou, seja por vitória, derrota ou empate.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_win</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">CPU_PLAYER</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">is_win</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">HUMAN_PLAYER</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">return</span> <span class="mi">0</span>
</code></pre></div>

<p>Estamos considerando o <strong><code>CPU_PLAYER</code></strong> como o <strong><code>MAX</code></strong> já que precisamos da melhor jogada para ele.</p>
<p>Com essa duas funções definidas já podemos começar a pensar na implementação do nosso Minimax. Como ele é recursivo, quem está familiarizado sabe, que a primeira coisa a ser definida é a condição de parada. No nosso caso verificamos se é um estado final e retornamos a avaliação.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">minimax</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_terminal</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">board</span><span class="p">)</span>
</code></pre></div>

<p>Para os estados intermediários precisamos saber se está na vez do <strong><code>MIN</code></strong> ou na vez do <strong><code>MAX</code></strong>, para tal, podemos passar um parâmetro chamado <strong><code>maximizing</code></strong>, assim saberemos se estamos maximizando ou minimizando. Colocaremos ele como <code>False</code> por padrão, apenas por fins de praticidade.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">minimax</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">maximizing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_terminal</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">board</span><span class="p">)</span>
</code></pre></div>

<p>Agora precisamos definir o que o algoritmo vai fazer em cada turno. No caso do <strong><code>MAX</code></strong> temos que analisar as possibilidades e pegar a maior pontuação. A recursividade atrapalha um pouco esse processo já que não temos acesso a pontuação dos outros estados. Uma forma simples de fazer isso seria atribuir o menor valor possível para uma variável e sempre que uma pontuação for maior que ela nós atualizamos esse valor. Dessa forma vamos garantir que no retorno vamos manter sempre a maior prontuação. Essa implementação está ilustrado abaixo.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">minimax</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">maximizing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_terminal</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">board</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">maximizing</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">CPU_PLAYER</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">minimax</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">value</span>
</code></pre></div>

<p>Note que quando o valor do <strong><code>maximizing</code></strong> for <strong><code>True</code></strong> precisamos passar para a próxima chamada o <strong><code>False</code></strong> para garantir que todos os turnos serão avaliados corretamente.</p>
<p>Para finalizar só precisamos fazer o mesmo para o <strong><code>MIN</code></strong>, só que com a lógica contrária, dessa vez vamos iniciar o valor com o número mais alto possível e pegar o mínimo entre as pontuações.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">minimax</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">maximizing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_terminal</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">board</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">maximizing</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">CPU_PLAYER</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">minimax</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;+inf&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">HUMAN_PLAYER</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">minimax</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">value</span>
</code></pre></div>

<p>Agora que já temos o nosso Minimax implementado e pronto para uso, só precisamos editar a nossa lógica de jogo. Para fazer isso é só substituir essa parte do código:</p>
<div class="highlight"><pre><span></span><code><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="k">while</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39; &#39;</span><span class="p">:</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">CPU_PLAYER</span>
</code></pre></div>

<p>por esta outra parte:</p>
<div class="highlight"><pre><span></span><code><span class="n">candidate_moves</span> <span class="o">=</span> <span class="n">candidates</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">CPU_PLAYER</span><span class="p">)</span>
<span class="n">board</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">candidate_moves</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">minimax</span><span class="p">)</span>
</code></pre></div>

<p>O que estamos fazendo é gerar os candidatos para a próxima jogada do computador. Essas jogadas vão passar pela função <strong><code>max</code></strong>, que é nativa do Python. Com o parâmetro <strong><code>key</code></strong> ela vai calcular a pontuação de cada um dos candidatos e retornar o candidato com a maior pontuação. Dessa forma, nós vamos conseguir deixar o computador mais inteligente.</p>
<p>Você pode encontrar o <a href="/docs/tic-tac-toe_minimax.py" target="_blank">código completo aqui</a>. Esse arquivo já possui tanto o jogo da velha quanto o Minimax.</p>
<p><a id="otimizando-com-a-poda-alfa-beta"></a></p>
<h3>Otimizando com a poda Alfa-Beta</h3>
<p>Você, possivelmente, está se perguntando porque chamamos a implementação anterior de ingênua. Se você executou o código da seção anterior deve ter notado uma demora para o computador executar a primeira jogada, principalmente se ele começar o jogo. Isso acontence por causa da quantidade de chamadas que ele faz para avaliar a árvore inteira. No jogo da velha para a primeira jogada, são mais de <strong>500 mil</strong> chamadas executadas à função <strong><code>minimax</code></strong>. Acredito que você tenha percebido o problema nessa abordagem. No caso do Xadrez que para apenas 10 lances tem quase <strong>70 trilhões</strong> de jogos possíveis, torna-se inviável de explorar toda a árvore de decisão.</p>
<p>Existem algumas formas de atenuar esse problema. Uma delas seria, sempre que detectarmos uma jogada que não vai acrescentar em nada a nossa solução, não precisamos expandir a partir dela, eliminando assim algum trabalho desnecessário. Mas como podemos detectar esse tipo de jogada? Nesse ponto entra a poda Alfa-Beta.</p>
<p>A <strong>poda Alfa-Beta</strong> é uma variação do algoritmo Minimax que visa reduzir a quantidade de estados que serão avaliados na árvore de busca.</p>
<p>A linha de pensamento é simples, Introduzimos duas novas variáveis <strong><code>alfa</code></strong> e <strong><code>beta</code></strong>, onde alfa é a melhor pontuação que já foi garantida para o <strong>MAX</strong> ao longo do caminho até o estado raiz, e beta é a melhor pontuação que já foi garantida para o <strong>MIN</strong>. Se estamos em um nível de MAX e ao longo de um caminho eu vejo que a pontuação gerada ao finalizar as verificações será menor que a garantida para o MAX, não faz sentido continuar expandindo dado que nunca vamos utilizá-la.</p>
<p>Achou difícil entender? Eu também! Talvez a implementação ajude você.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">minimax_alpha_beta</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">),</span> <span class="n">beta</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;+inf&#39;</span><span class="p">),</span> <span class="n">maximizing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_terminal</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">board</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">maximizing</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">CPU_PLAYER</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">minimax_alpha_beta</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;=</span> <span class="n">beta</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">alpha</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;+inf&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">HUMAN_PLAYER</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">minimax_alpha_beta</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="n">alpha</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">beta</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">value</span>
</code></pre></div>

<p>Não mudamos muito em relação ao código da seção anterior. A variáveis <strong><code>alfa</code></strong> e <strong><code>beta</code></strong> iniciam sempre com as piores pontuações possíveis para cada jogador, Infinito negativo e Infinito positivo respectivamente. Além disso inserimos novas verificações utilizando alfa e beta para quebar a cadeia recursiva quando não for vantajoso continuar expandido a partir dali.</p>
<p>Apenas com essas mudanças simples, conseguiremos reduzir a quantidade de chamadas recursivas de mais de <strong>500 mil</strong> para pouco mais de <strong>30 mil</strong>. Essa mudança reduziu em 94% o valor original.</p>
<p>Você pode encontrar o <a href="/docs/tic-tac-toe_alfa-beta.py" target="_blank">código completo aqui.</a></p>
<p><a id="aprimorando-ainda-mais-com-heuristicas"></a></p>
<h3>Aprimorando ainda mais com heurísticas</h3>
<p>Mesmo conseguindo reduzir drasticamente a quantidade de nós expandidos, podemos tentar minimizar ainda mais o trabalho que o nosso algoritmo terá. Uma das formas mais simples de fazer isso seria utilizando uma limitação de profundidade. Essa limitação seria algo como uma fronteira, onde o nosso algoritmo só conseguiria olhar algumas jogadas a frente.</p>
<p>Essa solução é simples, mas nos trás um problema que não tinhamos antes. Como avaliar estados que ainda não finalizaram?</p>
<p>Essa pergunta é bem plausível, dado que se limitarmos a nossa visão, podemos não chegar até uma vitória, derrota ou empate. Que bom que temos uma solução para esse problema. Vamos utilizar uma <strong>heurística</strong>.</p>
<p>Uma <strong>heurística</strong> é qualquer abordagem ou método que não é garantidamente ótimo, perfeito ou racional, mas geralmente é o suficiente para atingir uma apoximação imediata de curto prazo. Quando uma solução perfeita é impossível ou impaticável, ela pode ser utilizada para otimizar o processo de encontrar uma solução satisfatória. A heurística pode ser um atalho mental que ajude na tomada de decisão.</p>
<p>Para o jogo da velha podemos elaborar uma heurística simples que vai nos dar uma pontuação para estados intermediários. Seria ela:</p>
<ul>
<li>Se o computador venceu, retorne Infinito positivo.</li>
<li>Se o computador perdeu, retorne Infinito negativo.</li>
<li>Para cada 2 símbolos na linha, coluna ou diagonal em favor do computador (uma posição vazia) soma +10</li>
<li>Para 1 símbolo na linha, coluna ou diagonal em favor do computador (duas posições vazia) soma +1</li>
<li>Pontuações negativas, -10 e -1 considerando as mesmas situações, só que a favor do oponente</li>
<li>Caso contrário soma 0 (sequências vazias ou com simbolos do computador e do oponente ao mesmo tempo)</li>
</ul>
<p>Com essa heurística podemos saber que, se a pontuação for positiva, quer dizer que o computador está em vantagem, se for negativa, o oponente está em vantagem, e no caso de ser 0 o jogo está empatado.</p>
<p>Segue a implementação para a nossa função heurística:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">evaluate_heuristic_sequence</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
    <span class="n">number_of_blank</span> <span class="o">=</span> <span class="n">sequence</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="n">has_two_simbols</span> <span class="o">=</span> <span class="p">(</span><span class="n">CPU_PLAYER</span> <span class="ow">in</span> <span class="n">sequence</span> <span class="ow">and</span> <span class="n">HUMAN_PLAYER</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">number_of_blank</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">has_two_simbols</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">number_of_blank</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">CPU_PLAYER</span> <span class="ow">in</span> <span class="n">sequence</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">return</span> <span class="mi">10</span> <span class="k">if</span> <span class="n">CPU_PLAYER</span> <span class="ow">in</span> <span class="n">sequence</span> <span class="k">else</span> <span class="o">-</span><span class="mi">10</span>


<span class="k">def</span> <span class="nf">heuristic</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_win</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">CPU_PLAYER</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;+inf&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_win</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">HUMAN_PLAYER</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">)</span>

    <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Avaliando as linhas do tabuleiro</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">board</span><span class="p">:</span>
        <span class="n">score</span> <span class="o">+=</span> <span class="n">evaluate_heuristic_sequence</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

    <span class="c1"># Avaliando as colunas do tabuleiro</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">)):</span>
        <span class="n">column</span> <span class="o">=</span> <span class="p">[</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">))]</span>
        <span class="n">score</span> <span class="o">+=</span> <span class="n">evaluate_heuristic_sequence</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>

    <span class="c1"># Avaliando as diagonais do tabuleiro</span>
    <span class="n">main_diag</span> <span class="o">=</span> <span class="p">[</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">))]</span>
    <span class="n">secondary_diag</span> <span class="o">=</span> <span class="p">[</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))]</span>

    <span class="n">score</span> <span class="o">+=</span> <span class="n">evaluate_heuristic_sequence</span><span class="p">(</span><span class="n">main_diag</span><span class="p">)</span>
    <span class="n">score</span> <span class="o">+=</span> <span class="n">evaluate_heuristic_sequence</span><span class="p">(</span><span class="n">secondary_diag</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">score</span>
</code></pre></div>

<p>Dividimos a nossa implementação em duas funções apenas para fins de praticidade. A ideia é que a função <strong><code>evaluate_heuristic_sequence</code></strong> vai definir as regras da nossa heurística e a função <strong><code>heuristic</code></strong> vai verificar linhas colunas e diagonais para retornar a pontuação do estado que foi passado.</p>
<p>As mudanças dessa versão em relação a da seção Alfa-Beta são bem simples. Vamos adicionar uma variável para controlar a profundidade de expansão da árvore e trocar a função <strong><code>evaluate</code></strong> pela função <strong><code>heuristic</code></strong>.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">minimax_heuristic</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">),</span>
                      <span class="n">beta</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;+inf&#39;</span><span class="p">),</span> <span class="n">maximizing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">depth</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">is_terminal</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">heuristic</span><span class="p">(</span><span class="n">board</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">maximizing</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">CPU_PLAYER</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="n">value</span><span class="p">,</span>
                <span class="n">minimax_heuristic</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;=</span> <span class="n">beta</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">alpha</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;+inf&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">HUMAN_PLAYER</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">value</span><span class="p">,</span>
                <span class="n">minimax_heuristic</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="n">alpha</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">beta</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">value</span>
</code></pre></div>

<p>Nesse trecho de código você vai notar que colocamos a verificação <strong><code>depth==0</code></strong> para finalizar a execução quando atingirmos a profundidade máxima. Para garantir essa finalização precisamos decrementar essa variável nas próximas chamadas da função <strong><code>minimax_heuristic</code></strong>. Com essas mudanças vamos conseguir reduzir as chamadas recursivas ainda mais. Das <strong>30 mil</strong> da seção anterior, passamos para pouco mais de <strong>300</strong> chamadas.</p>
<p>Uma coisa interessante de apontar é que, se você é um jogador entusiasta de jogo da velha, saberá que um jogador ótimo sempre começará o jogo nos cantos. No Minimax ingênuo e na abordagem com Alfa-Beta percebemos que isso fica bem visível quando deixamos o computador começar. Já nessa abordagem utilizando heurística e considerando a profundidade igual a 2, vemos que isso não acontece, porém o computador ainda é invencível. Essa é uma característica intrigante da utilização de heurísticas, nem sempre é garantido que vamos encontrar a solução ótima, dado que estamos flexibilizando o problema para poder resolvê-lo.</p>
<p>Você pode encontrar o <a href="/docs/tic-tac-toe_heuristic.py" target="_blank">código completo aqui.</a></p>
<p><a id="recapitulando"></a></p>
<h2>Recapitulando...</h2>
<p>O que fizemos hoje:</p>
<ul>
<li>Constuímos o nosso jogo da velha</li>
<li>Entendemos o que é o Minimax e como ele pode ser utilizado</li>
<li>Implementamos o Minimax padrão para o jogo</li>
<li>Vimos que a implementação ingênua do Minimax tem certos problemas</li>
<li>Implementamos otimizações</li>
</ul>
<p>Conseguimos fazer o nosso algoritmo super inteligente para jogar o jogo da velha. Vimos que ele tem alguns problemas, mas com a técnica correta eles podem ser contornados. Sinta-se a vontade para procurar outras otimizações e quem sabe aplicar até em outros jogos. Um exercício interessante é pensar quais são os jogos em que ele pode ser aplicado.</p>
<p>Para você que acompanhou esse artigo até o final, muito obrigado pela sua atenção e até o próximo... bye bye</p>
      </div>
      <div class="back-to-top">
          <a href="#top">voltar ao topo</a>
      </div>
      <div id="disqus_thread"></div>
        <script>
        (function() {
              var d = document, s = d.createElement('script');
              s.src = 'https://lemsantos-1.disqus.com/embed.js';
              s.setAttribute('data-timestamp', +new Date());
              (d.head || d.body).appendChild(s);
        })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </article>
  </div>
<!-- end article -->
                <footer>
                    <div class="icons">
                        <a href="https://github.com/lemsantos" target="_blank"><div class="icon-github icon"></div></a>
                        <a href="https://www.linkedin.com/in/lucas-eliaquim/" target="_blank"><div class="icon-linkedin icon"></div></a>
                        <a href="mailto:lemsantos.dev@gmail.com" target="_blank"><div class="icon-mail icon"></div></a>
                    </div>
                    <p>© <script>document.write(moment().format('YYYY'));</script> Lucas Eliaquim</p>
                    <p><i>"Brutal"</i> Pelican Theme</p>
                    <p>Designed and built by <a href="http://twitter.com/mcman_s">@mcman_s</a> in Denver</p>
                </footer>
        </div>
</body>
</html>